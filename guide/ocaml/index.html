<!DOCTYPE html>
 <html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAnhJREFUWAljvOtj+Z9hoAAj42OmgbIbZu+oA0ZDYDQERkNgNARGQ2A0BFhg1SJOmpmZgZGJGUX6/39gE+LPbxQxZA4jKxsyFyv7/98/DAxAcwg6QLy8hYHb0h7DkL9fPjH8fvaE4fOuzQyfd29hYPj3F6yGWUCQQX7xVgz16AKvJ3cA9W0m7AB0jTA+Mw8fA7OaFgMHEHNb2DK8aCyBSZFEEwwBZNO+nTvJ8OPaRQYGRkYGVkkZBh47VwZGFhYGLhMrBh5HD4Yv+3cgKwez36+Yx/D/DzC40cDPOzfAIiQ54PvF0wwf1y2DG/Xr0X0G4YQsMJ9DWx+rAz6sXcrw/8d3uB4UBtAjJDkARTOQ8/vhPbgQs4AwnI3MADns/8+fyEIM/759Zfh17xZYjHwHAHMHj5Mn3OA/L5/C2cgMyYY+ZC6Y/ePGFYZnpWlgNkkO4PcLZ+CxdQFqBAadmAQDMx8/2JD/f/8yfN67HcwmlSDJASzCogwgjAxACezNrD54kCLLgdgvmkvBUQDufIDKDyD49/UzmAYRJDng19NHDH9ePmNgZOdg4NQ2ABvyGyj2eedmuIHojO+XzuFOhKQ64POuTfBcIN03l4FdVZOBTV6JgT8wkuHj2iXodoP5/D4h2LPh3ZsMP66cJy0EkG14t3gmg2TTBLCQYGQyw9ej+xn+vMBMiELxmcja4OyPm1aBHUB2bfj9/CmG75fPgw1kYmdnEMkugxtOCoORUOeUkYMTXNqBDAXl5/+/f8HNB1U6jEDLYeDfF0jiYuLhhQnhpEHm/P/16zHBRAgqxSBpF9MssCFIDoKpgDkExsdJg0tCRoaPOBXQXuITAIHczlO/UBn+AAAAAElFTkSuQmCC"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="preload" href="/page-component---src-templates-guide-js-c00cda49ee7c0a36f228.js" as="script"/><link rel="preload" href="/path---guide-ocaml-2ca14420b62310f8bbae.js" as="script"/><link rel="preload" href="/layout-component---index-d0aae321ed992887c3a0.js" as="script"/><link rel="preload" href="/app-8d16c4f4261e1575349c.js" as="script"/><link rel="preload" href="/commons-e74c9824bed8c5e5e82a.js" as="script"/><script id="webpack-manifest">
            //<![CDATA[
            window.webpackManifest = {"1":"layout-component---index-d0aae321ed992887c3a0.js","2":"page-component---src-templates-guide-js-c00cda49ee7c0a36f228.js","3":"page-component---src-pages-try-js-53876df3f7b5d6a55e91.js","4":"page-component---src-pages-index-js-de5c8988ea164eea2cc4.js","5":"page-component---src-pages-community-examples-js-20a2306d5f06aa7325f6.js","6":"page-component---src-templates-search-js-e9674273a0d821018daa.js","7":"path---try-586c7e095e534a3909ec.js","8":"path---index-088e597fc136add51ada.js","9":"path---guide-f7efddad5be169b30776.js","10":"path---guide-tools-928a2e90390d6cd26f84.js","11":"path---guide-search-97b846e91a33ce7c3ba2.js","12":"path---guide-ocaml-2ca14420b62310f8bbae.js","13":"path---guide-native-1e29478e265c001e0c6b.js","14":"path---guide-native-quickstart-73139682501334ce7f3a.js","15":"path---guide-native-convert-from-ocaml-8c6e6e205bc8547bf6b1.js","16":"path---guide-language-a072d823f41684039d39.js","17":"path---guide-language-types-b8555baeb79735a77af5.js","18":"path---guide-language-primitives-4a1fefe4aa102d247fdf.js","19":"path---guide-language-mutation-55dd8f8b5ed53afec0b6.js","20":"path---guide-language-more-types-8c23c8d74dbccdd52dca.js","21":"path---guide-language-more-functions-744e524a7c1ae03c01a2.js","22":"path---guide-language-modules-f336973ba09a7d19aa70.js","23":"path---guide-language-let-bindings-4ee4f0a3cb12be94f2db.js","24":"path---guide-language-jsx-57df0f19c28c80b906df.js","25":"path---guide-language-imperative-loops-d95516e2cd4a554c32b2.js","26":"path---guide-language-functions-0637edc247473bb90f4e.js","27":"path---guide-language-destructuring-cb1f06bdaf34dd8be6b0.js","28":"path---guide-language-data-types-294c24b910a6b1205747.js","29":"path---guide-language-conditionals-2e4eb827341078516256.js","30":"path---guide-javascript-b52538f85295195d04a8.js","31":"path---guide-javascript-syntax-cheetsheet-c6bb27f0d0740b39bf43.js","32":"path---guide-javascript-quickstart-a1d695f61f5b07af6c99.js","33":"path---guide-javascript-libraries-2a10328aea5e5b95bbd1.js","34":"path---guide-javascript-interop-741080e9104c90a49865.js","35":"path---guide-javascript-converting-33136924b80799c71689.js","36":"path---guide-getting-started-357158798448263a211c.js","37":"path---guide-examples-9caa12719776e054e895.js","38":"path---guide-editor-setup-0e0a8a4ff88598d5ad4e.js","39":"path---community-77511c6e4981e59a70ad.js","40":"path---community-search-41c5d73798905510e5ae.js","41":"path---community-roadmap-caf3ccd6b9e4c087c4b2.js","42":"path---community-faq-69cbf39a850c50c45cf7.js","43":"path---community-examples-169ab4a6c86d93a2280e.js","44":"path---community-events-cb7b2d4de8dab4ab78c4.js","45":"path---community-blog-6f3144de4b4f2b1b8db8.js","46":"path---community-articles-and-videos-3dc2eb9e9bc0a1752b9c.js","47":"app-8d16c4f4261e1575349c.js"}
            //]]>
            </script><title data-react-helmet="true">Comparison to OCaml</title><script>
  !function(e,t,r){function n(){for(;d[0]&&"loaded"==d[0][f];)c=d.shift(),c[o]=!i.parentNode.insertBefore(c,i)}for(var s,a,c,d=[],i=e.scripts[0],o="onreadystatechange",f="readyState";s=r.shift();)a=e.createElement(t),"async"in i?(a.async=!1,e.head.appendChild(a)):i[f]?(d.push(a),a[o]=n):e.write("<"+t+' src="'+s+'" defer></'+t+">"),a.src=s}(document,"script",[
  "/commons-e74c9824bed8c5e5e82a.js","/app-8d16c4f4261e1575349c.js","/layout-component---index-d0aae321ed992887c3a0.js","/path---guide-ocaml-2ca14420b62310f8bbae.js","/page-component---src-templates-guide-js-c00cda49ee7c0a36f228.js"
])
  </script><style id="typography.js">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:112.5%/1.45em 'Helvetica Neue','Helvetica','Arial','Lucida Grande','sans-serif';box-sizing:border-box;overflow-y:scroll;}*{box-sizing:inherit;}*:before{box-sizing:inherit;}*:after{box-sizing:inherit;}body{color:hsla(0,0%,0%,0.8);font-family:'Helvetica Neue','Helvetica','Arial','Lucida Grande','sans-serif';font-weight:normal;word-wrap:break-word;font-kerning:normal;-moz-font-feature-settings:"kern", "liga", "clig", "calt";-ms-font-feature-settings:"kern", "liga", "clig", "calt";-webkit-font-feature-settings:"kern", "liga", "clig", "calt";font-feature-settings:"kern", "liga", "clig", "calt";}img{max-width:100%;margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}h1{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:'Helvetica Neue','Helvetica','Arial','Lucida Grande','sans-serif';font-weight:bold;text-rendering:optimizeLegibility;font-size:2.25rem;line-height:2.9rem;}h2{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:'Helvetica Neue','Helvetica','Arial','Lucida Grande','sans-serif';font-weight:bold;text-rendering:optimizeLegibility;font-size:1.62671rem;line-height:2.175rem;}h3{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:'Helvetica Neue','Helvetica','Arial','Lucida Grande','sans-serif';font-weight:bold;text-rendering:optimizeLegibility;font-size:1.38316rem;line-height:2.175rem;}h4{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:'Helvetica Neue','Helvetica','Arial','Lucida Grande','sans-serif';font-weight:bold;text-rendering:optimizeLegibility;font-size:1rem;line-height:1.45rem;}h5{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:'Helvetica Neue','Helvetica','Arial','Lucida Grande','sans-serif';font-weight:bold;text-rendering:optimizeLegibility;font-size:0.85028rem;line-height:1.45rem;}h6{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:'Helvetica Neue','Helvetica','Arial','Lucida Grande','sans-serif';font-weight:bold;text-rendering:optimizeLegibility;font-size:0.78405rem;line-height:1.45rem;}hgroup{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}ul{margin-left:1.45rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;list-style-position:outside;list-style-image:none;}ol{margin-left:1.45rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;list-style-position:outside;list-style-image:none;}dl{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}dd{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}p{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}figure{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}pre{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;font-size:0.85rem;line-height:1.42;background:hsla(0,0%,0%,0.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem;}table{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%;}fieldset{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}blockquote{margin-left:1.45rem;margin-right:1.45rem;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}form{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}noscript{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}iframe{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}hr{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:calc(1.45rem - 1px);background:hsla(0,0%,0%,0.2);border:none;height:1px;}address{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}b{font-weight:bold;}strong{font-weight:bold;}dt{font-weight:bold;}th{font-weight:bold;}li{margin-bottom:calc(1.45rem / 2);}ol li{padding-left:0;}ul li{padding-left:0;}li > ol{margin-left:1.45rem;margin-bottom:calc(1.45rem / 2);margin-top:calc(1.45rem / 2);}li > ul{margin-left:1.45rem;margin-bottom:calc(1.45rem / 2);margin-top:calc(1.45rem / 2);}blockquote *:last-child{margin-bottom:0;}li *:last-child{margin-bottom:0;}p *:last-child{margin-bottom:0;}li > p{margin-bottom:calc(1.45rem / 2);}code{font-size:0.85rem;line-height:1.45rem;}kbd{font-size:0.85rem;line-height:1.45rem;}samp{font-size:0.85rem;line-height:1.45rem;}abbr{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}acronym{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}abbr[title]{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;text-decoration:none;}thead{text-align:left;}td,th{text-align:left;border-bottom:1px solid hsla(0,0%,0%,0.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding-left:0.96667rem;padding-right:0.96667rem;padding-top:0.725rem;padding-bottom:calc(0.725rem - 1px);}th:first-child,td:first-child{padding-left:0;}th:last-child,td:last-child{padding-right:0;}tt,code{background-color:hsla(0,0%,0%,0.04);border-radius:3px;font-family:"SFMono-Regular", Consolas,"Roboto Mono","Droid Sans Mono","Liberation Mono",Menlo,Courier,monospace;padding:0;padding-top:0.2em;padding-bottom:0.2em;}pre code{background:none;line-height:1.42;}code:before,code:after,tt:before,tt:after{letter-spacing:-0.2em;content:" ";}pre code:before,pre code:after,pre tt:before,pre tt:after{content:"";}@media only screen and (max-width:480px){html{font-size:100%;}}</style><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#fff;color:#000;-webkit-text-size-adjust:none}.hljs-comment{color:#006a00}.hljs-keyword,.hljs-literal,.nginx .hljs-title{color:#aa1094}.hljs-list .hljs-title,.hljs-name,.hljs-request,.hljs-status,.hljs-tag .hljs-title,.hljs-winutils,.http .hljs-title,.method,.setting .hljs-value,.tex .hljs-command{color:#008}.hljs-envvar,.tex .hljs-special{color:#660}.hljs-string{color:#c41a16}.apache .hljs-cbracket,.hljs-attr_selector,.hljs-cdata,.hljs-date,.hljs-filter .hljs-argument,.hljs-regexp,.hljs-tag .hljs-value{color:#080}.coffeescript .hljs-attribute,.css .hljs-function,.hljs-decorator,.hljs-function .hljs-title,.hljs-hexcolor,.hljs-number,.hljs-pi,.hljs-prompt,.hljs-rule .hljs-value,.hljs-shebang,.hljs-sub .hljs-identifier,.hljs-symbol,.hljs-symbol .hljs-string,.hljs-tag,.hljs-tag .hljs-keyword,.ini .hljs-title{color:#1c00cf}.clojure .hljs-attribute,.hljs-built_in,.hljs-class .hljs-id,.hljs-class .hljs-title,.hljs-doctype,.hljs-tag .hljs-attribute,.hljs-type,.hljs-typename,.setting,.smalltalk .hljs-class{color:#5b2f8e}.hljs-params,.hljs-variable{color:#3f6e74}.css .hljs-tag,.hljs-pseudo,.hljs-rule .hljs-property,.hljs-subst{color:#000}.css .hljs-class,.css .hljs-id{color:#9b703f}.hljs-value .hljs-important{color:#f70;font-weight:700}.hljs-rule .hljs-keyword{color:#c5af75}.apache .hljs-sqbracket,.hljs-annotation,.nginx .hljs-built_in{color:#9b859d}.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor *{color:#643820}.tex .hljs-formula{background-color:#eee;font-style:italic}.diff .hljs-header,.hljs-chunk{color:gray;font-weight:700}.diff .hljs-change{background-color:#bccff9}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-comment .hljs-doctag{font-weight:700}.method .hljs-id{color:#000}.hljs{background:#fbfafa;border:1px solid #eee;display:block;padding:10px;border-radius:1px;overflow:auto}td>pre{padding:5px 15px;margin:0}.CodeMirror{font-family:monospace;height:300px;color:#000}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:blue}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-invalidchar,.cm-s-default .cm-error{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:none;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;-webkit-font-feature-settings:"calt";font-feature-settings:"calt";font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:none}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}.CodeMirror-focused div.CodeMirror-cursors,div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background:#ffa;background:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:""}span.CodeMirror-selectedtext{background:none}div{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-ms-flex-negative:0;flex-shrink:0;min-width:0;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch}</style></head><body><div id="___gatsby"><div data-reactroot="" data-reactid="1" data-react-checksum="325700027"><!-- react-empty: 2 --><style>.css-4msjtb,[data-css-4msjtb]{background-color:#db4d3f;flex-direction:row;justify-content:center;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;-ms-flex-pack:center;-webkit-box-pack:center;-webkit-justify-content:center;}</style><div class="css-4msjtb" data-reactid="3"><style>.css-1y8eyh,[data-css-1y8eyh]{color:white;}.css-11xmer7,[data-css-11xmer7]{max-width:1270px;flex:1;-webkit-flex:1;-ms-flex:1;}</style><div class="css-1y8eyh css-11xmer7" data-reactid="4"><style>.css-yzv3nw,[data-css-yzv3nw]{flex-direction:row;justify-content:space-between;align-items:center;padding:10px 10px;padding-left:2em;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;-ms-flex-pack:justify;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-align:center;-webkit-box-align:center;-webkit-align-items:center;}@media(max-width: 400px){.css-yzv3nw,[data-css-yzv3nw]{padding-left:10px;height:auto;}}</style><div class="css-yzv3nw" data-reactid="5"><a style="text-decoration:none;color:currentColor;" href="/" data-reactid="6"><img style="width:50px;max-width:50px;margin:0;border:2px solid #f6f4f4;box-sizing:content-box;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAABGdBTUEAALGPC/xhBQAABh9JREFUeAHtm2toHFUUx8/s7CabbB67eaGhVWtFsWixCJX4bMT4gPSDglSLWlqqBq2SUpUiVhTFDyIIweITik0taKHF+vig+SCNFmuLVIu2iqG1ukmatJtukt1kn+Pc1T3Z7O5kJrvTzbnrGVhy7j1n7v7v/5d53UyUgc42DXgj4YCiKL0OEkpYBDrAQNAKGgEDocEBVTAQtIJGwEBocEAVDAStoBEwEBocUAUDQStoBAyEBgdUwUDQChoBA6HBAVUwELSCRsBAaHBAFQwEraARMBAaHFAFA0EraAQMhAYHVMFA0AoaAQOhwQFVMBC0gkbAQGhwQBUMBK2gETAQGhxQBQNBK2gEDIQGB1TBQNAKGgEDocEBVTAQtIJGwEBocEAVDAStoBEwEBocUAUDQStoBAyEBgdUwUDQChoBA6HBAVUwELSCRsBAaHBAFQwEraARMBAaHFAFA0EraAQMhAYHVMFA0AoaAQOhwQFVMBC0gkbAQGhwQBUMBK2gETAQGhxQBQNBK2gEDIQGB1TBQNAKGgEDocEBVTAQtIJG4CyVjCX7DhT9VVo0AsnJCUiEJiFxPgDRP07A9O+/QuTEMb09VvD4Lc++DJ4b2wvev6AdtSScvG9Vzq4lA6I4i/8qMYaj2gPpkapXrExNSEskIHzkIIx/uRemfjyUM0nTDocKdugz/Z6MAi2ZzGjNhOm5zfRIGCmqCp4bbkl9po//DCNvvgLxIb+EMwEou2uI++rlsKinF2ra72YgVBxwuN3Q3P0C1NzWQUWSZR1ld4SkZ644HNC8eRu4r7ku3SXFz7IFItxXVCc0dW3RT8zyTJPURV1LxCERPG/4m6zW1oHiqjDM50tUXLoUau/ohImv9udLz6tP3Gob3R3NayBRLMNdVvT0SfA/vc54booCzqYWqLjsCvA+sB7cVy4zrs3I1LTfZQsQ/3Nd+t3b3xkj2x/KcyyLuWsaxEfPQPjwdzC4ZSOc2/GWJUfEnZfDU2updqGL5AKS5VZw724IHfwmqze3KZ5T3MuW5yYI9kgNRPgZ+PBtS7aqvkZLdQtdJD2QmH5OT0Yipj6qXp9pDYUC6YGkrivD5hdapdJNwW9TDaRue03VGhSoviaDzEx3InB2plFgJG6553vbne+rtFg0X3eqT3ogjnofqHX1hhNMJ+LnRtNhwT8Xb99V8L6ZO55a0wHJcCizC2PpT1m1q+7EycwVxM+OzJUmk5MaiKt1Mfge7jI1U5wiYv7TpnUUCuQ8ZelP7LUdq6HhkcfBUVlp6mPo+37QpsKmdRQKSAFRvY3gfXCDoS9qnRdcrYug4pLLU0sohoVZiYm+z7N66DZJAXH6GqBh7UZb3YqNDMHU0cO2jnkhB5P6GmJmjFg9HnnjJcOVVbP9FyJP6gix24DAju0QOX7MtmFjw4Mw6xlCX+wUD6b/biIWzcx2qgPT/xXMuYRftkCCn+2B4Kcf2wZDDDT0YvcFX34vOyCJ8SCM9rwG4UP9tsIo1WBlBUSLxcC/eT3ER4ZL5Z/t31NWF3XF5dJf/7nHdpNKOSCpI0T8NTCw+wPD+XvvXas/gywxzIuEb806CPX3QWzwrznrqCZJAUlMjsNk3xeGXiX168NF2143zIuEWI1t2rQVhp5/cs46qkmpTlnhH76F6d9+MfWy6toV+tJKp2ndfAtSS+9OF4BdH/2d4uyN1BGSLS5fO9D7LrS+2pMvNauvYcOm1MsQxbwVP2tAvWHX8nt63LE9O2Fs5zvpZuqnVEeIUDz90xGY0j9mm1pTB42PdpuVkctLB0Q4KI4SK1vNrR1QdX2blVIyNVICiejXkZDFB7+mJ54BWf6eLn4rpAQihI/tei9j3Uj05N9cLReD76HH8icJ9koLJHpqAEIHvrZkaf3q+6Fi6VWWahe6SFogwrjAR++DWGI328Sbi81PbZXiLfiS3fZGLfxNO35myMzbWXnxb2vB/Z9A9cqbZ/XnayjuKvDcdHvqKT47nwiMghV92fsV206O577prwx0tqUX8Isdn/cv0gFFUXqlPmUVOX+SuzMQYlgYCAMh5gAxOXyEMBBiDhCTw0cIMSBOBZSjxDT9f+Uo8Oc/4JtPde0zwz8AAAAASUVORK5CYII=" width="50" data-reactid="7"/></a><style>.css-1owbun0,[data-css-1owbun0]{flex-direction:row;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;}</style><div class="css-1owbun0" data-reactid="8"><style>.css-hqlbx8,[data-css-hqlbx8]{padding:15px;}@media(max-width: 550px){.css-hqlbx8,[data-css-hqlbx8]{padding:5px;}}@media(max-width: 400px){.css-hqlbx8,[data-css-hqlbx8]{padding:5px;font-size:.9em;}}.css-1coze92,[data-css-1coze92]{text-decoration:none;color:currentColor;}.css-1coze92:hover,[data-css-1coze92]:hover{text-decoration:underline;}</style><a class="css-hqlbx8 css-1coze92" href="/guide/javascript/quickstart" data-reactid="9">quickstart</a><a class="css-hqlbx8 css-1coze92" href="/try/" data-reactid="10">try</a><a class="css-hqlbx8 css-1coze92" href="/guide/" data-reactid="11">guide</a><a class="css-hqlbx8 css-1coze92" href="/community/" data-reactid="12">community</a><a class="css-hqlbx8 css-1coze92" href="/community/blog/" data-reactid="13">blog</a><a href="https://github.com/facebook/reason" class="css-hqlbx8 css-1coze92" data-reactid="14">github</a></div></div><style>.css-1k8tu3j,[data-css-1k8tu3j]{align-items:center;-ms-flex-align:center;-webkit-box-align:center;-webkit-align-items:center;}</style><div class="css-1k8tu3j" data-reactid="15"><h1 data-reactid="16"><a class="css-1coze92" href="/guide" data-reactid="17">Guide</a></h1></div></div></div><style>.css-1q2z82c,[data-css-1q2z82c]{flex-direction:row;justify-content:center;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;-ms-flex-pack:center;-webkit-box-pack:center;-webkit-justify-content:center;}</style><div class="css-1q2z82c" data-reactid="18"><style>.css-1c6ulfs,[data-css-1c6ulfs]{flex-direction:row;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;}@media(max-width: 800px){.css-1c6ulfs,[data-css-1c6ulfs]{flex-direction:column;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;}}</style><div class="css-1c6ulfs css-11xmer7" data-reactid="19"><style></style><div class="css-nil" data-reactid="20"><style>.css-9ypbri,[data-css-9ypbri]{width:200px;font-size:14px;line-height:14px;}@media(max-width: 800px){.css-9ypbri,[data-css-9ypbri]{width:auto;}}</style><div class="css-9ypbri" data-reactid="21"><style>.css-yw845w,[data-css-yw845w]{background-color:#444;color:white;padding:1em 2em;align-self:stretch;display:none;cursor:pointer;-ms-flex-item-align:stretch;-webkit-align-self:stretch;}@media(max-width: 800px){.css-yw845w,[data-css-yw845w]{display:-webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex;}}</style><div class="css-yw845w" data-reactid="22">Navigation</div><style>.css-1e5zzey,[data-css-1e5zzey]{padding:2em;}@media(max-width: 800px){.css-1e5zzey,[data-css-1e5zzey]{display:none;}}</style><div class="css-1e5zzey" data-reactid="23"><a class="css-1coze92" href="/guide/search" data-reactid="24">Search</a><div class="css-nil" data-reactid="25"><style>.css-1kea2mb,[data-css-1kea2mb]{list-style:none;margin:0;padding:0;padding-left:0;margin-left:0;border-left:none;}</style><ul class="css-1kea2mb" data-reactid="26"><li style="margin:0;padding:0;" data-reactid="27"><style>.css-15sufuq,[data-css-15sufuq]{text-decoration:none;color:currentColor;line-height:1.2em;padding-bottom:3px;padding-top:5px;display:block;font-weight:bold;font-size:1.2em;}</style><a class="css-15sufuq css-1coze92" href="/guide/getting-started" data-reactid="28">Getting started</a></li><li style="margin:0;padding:0;" data-reactid="29"><a class="css-15sufuq css-1coze92" href="/guide/editor-setup" data-reactid="30">Editor setup</a></li><li style="margin:0;padding:0;" data-reactid="31"><div class="css-nil" data-reactid="32"><a class="css-15sufuq css-1coze92" href="/guide/language" data-reactid="33">Language basics</a><style>.css-iiaw3p,[data-css-iiaw3p]{list-style:none;margin:0;padding:0;padding-left:15px;margin-left:0;border-left:1px solid #aaa;}</style><ul class="css-iiaw3p" data-reactid="34"><li style="margin:0;padding:0;" data-reactid="35"><style>.css-17dgi4v,[data-css-17dgi4v]{text-decoration:none;color:currentColor;line-height:1.2em;padding-bottom:3px;padding-top:5px;display:block;}</style><a class="css-17dgi4v css-1coze92" href="/guide/language/primitives" data-reactid="36">Primitives</a></li><li style="margin:0;padding:0;" data-reactid="37"><a class="css-17dgi4v css-1coze92" href="/guide/language/types" data-reactid="38">Types</a></li><li style="margin:0;padding:0;" data-reactid="39"><a class="css-17dgi4v css-1coze92" href="/guide/language/let-bindings" data-reactid="40">Let Bindings</a></li><li style="margin:0;padding:0;" data-reactid="41"><a class="css-17dgi4v css-1coze92" href="/guide/language/data-types" data-reactid="42">Built-in Data Types</a></li><li style="margin:0;padding:0;" data-reactid="43"><a class="css-17dgi4v css-1coze92" href="/guide/language/functions" data-reactid="44">Functions</a></li><li style="margin:0;padding:0;" data-reactid="45"><a class="css-17dgi4v css-1coze92" href="/guide/language/conditionals" data-reactid="46">Conditionals</a></li><li style="margin:0;padding:0;" data-reactid="47"><a class="css-17dgi4v css-1coze92" href="/guide/language/destructuring" data-reactid="48">Destructuring &amp; Pattern Matching</a></li><li style="margin:0;padding:0;" data-reactid="49"><a class="css-17dgi4v css-1coze92" href="/guide/language/more-functions" data-reactid="50">More on Functions</a></li><li style="margin:0;padding:0;" data-reactid="51"><a class="css-17dgi4v css-1coze92" href="/guide/language/more-types" data-reactid="52">More on Types</a></li><li style="margin:0;padding:0;" data-reactid="53"><a class="css-17dgi4v css-1coze92" href="/guide/language/mutation" data-reactid="54">Mutation</a></li><li style="margin:0;padding:0;" data-reactid="55"><a class="css-17dgi4v css-1coze92" href="/guide/language/imperative-loops" data-reactid="56">Imperative Loops</a></li><li style="margin:0;padding:0;" data-reactid="57"><a class="css-17dgi4v css-1coze92" href="/guide/language/jsx" data-reactid="58">JSX</a></li><li style="margin:0;padding:0;" data-reactid="59"><a class="css-17dgi4v css-1coze92" href="/guide/language/modules" data-reactid="60">Modules</a></li></ul></div></li><li style="margin:0;padding:0;" data-reactid="61"><a class="css-15sufuq css-1coze92" href="/guide/tools" data-reactid="62">Tools</a></li><li style="margin:0;padding:0;" data-reactid="63"><div class="css-nil" data-reactid="64"><a class="css-15sufuq css-1coze92" href="/guide/javascript" data-reactid="65">JavaScript</a><ul class="css-iiaw3p" data-reactid="66"><li style="margin:0;padding:0;" data-reactid="67"><a class="css-17dgi4v css-1coze92" href="/guide/javascript/quickstart" data-reactid="68">Quickstart</a></li><li style="margin:0;padding:0;" data-reactid="69"><a class="css-17dgi4v css-1coze92" href="/guide/javascript/interop" data-reactid="70">Interop</a></li><li style="margin:0;padding:0;" data-reactid="71"><a class="css-17dgi4v css-1coze92" href="/guide/javascript/syntax-cheetsheet" data-reactid="72">Syntax cheetsheet</a></li><li style="margin:0;padding:0;" data-reactid="73"><a class="css-17dgi4v css-1coze92" href="/guide/javascript/libraries" data-reactid="74">Libraries</a></li><li style="margin:0;padding:0;" data-reactid="75"><a class="css-17dgi4v css-1coze92" href="/guide/javascript/converting" data-reactid="76">Converting from JS</a></li></ul></div></li><li style="margin:0;padding:0;" data-reactid="77"><div class="css-nil" data-reactid="78"><a class="css-15sufuq css-1coze92" href="/guide/native" data-reactid="79">Native</a><ul class="css-iiaw3p" data-reactid="80"><li style="margin:0;padding:0;" data-reactid="81"><a class="css-17dgi4v css-1coze92" href="/guide/native/quickstart" data-reactid="82">Quickstart</a></li><li style="margin:0;padding:0;" data-reactid="83"><a class="css-17dgi4v css-1coze92" href="/guide/native/convert-from-ocaml" data-reactid="84">Converting from OCaml</a></li></ul></div></li><li style="margin:0;padding:0;" data-reactid="85"><style>.css-v2xins,[data-css-v2xins]{text-decoration:underline;color:#db4d3f;line-height:1.2em;padding-bottom:3px;padding-top:5px;display:block;font-weight:bold;font-size:1.2em;text-decoration-color:#db4d3f;-webkit-text-decoration-color:#db4d3f;-moz-text-decoration-color:#db4d3f;}</style><a class="css-v2xins css-1coze92" href="/guide/ocaml" data-reactid="86">Comparison to OCaml</a></li><li style="margin:0;padding:0;" data-reactid="87"><a class="css-15sufuq css-1coze92" href="/guide/examples" data-reactid="88">Examples</a></li></ul></div></div></div></div><style>.css-1kzda52,[data-css-1kzda52]{position:relative;flex:1;padding:2em;min-width:0;-webkit-flex:1;-ms-flex:1;}</style><div class="css-1kzda52" data-reactid="89"><style>.css-1cdevmu,[data-css-1cdevmu]{border-bottom:1px solid #aaa;display:-webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex;flex-direction:row;justify-content:space-between;align-items:flex-end;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;-ms-flex-pack:justify;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-align:end;-webkit-box-align:end;-webkit-align-items:flex-end;}</style><h2 class="css-1cdevmu" data-reactid="90"><!-- react-text: 91 -->Comparison to OCaml<!-- /react-text --><style>.css-rx9qxa,[data-css-rx9qxa]{font-size:14px;font-weight:normal;line-height:25px;}</style><a href="https://github.com/reasonml/reasonml.github.io/edit/source/src/pages/guide/ocaml.md" class="css-rx9qxa css-1coze92" data-reactid="92">Suggest an edit</a></h2><div data-reactid="93"><p>A quick reference for OCaml programmers.</p>
<p>Consult the general <a href="index.html#syntax-basics">Syntax Basics</a> for an overview
of the <code>Reason</code> syntax. This guide merely dives deeper into the differences and
improvements that OCaml programmers would notice most.</p>
<h3>Comments</h3>
<p>Reason comments use the C-family style of comments, and OCaml comments use <code>(* *)</code> style comments. In Reason, nested <code>/**/</code> comments are validated at parse
time, and in OCaml, nested <code>(* *)</code> are validated at parse time.
Reason will also <em>eventually</em> support line comments, which are not supported in OCaml.</p>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p >OCaml</p></th> <th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <code>
`(* OCaml (*nest*) *)`
      </code>
    </td>
    <td>
      <code>
`/* Reason /*nest*/  */`
      </code>
    </td>
  </tr>
</table>
<h3>REPL (<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">Read-Eval-Print-Loop</a>)</h3>
<p>In <code>Reason</code>'s repl <code>rtop</code> (a customized <code>utop</code>), each input is submitted via
a single <code>;</code> semicolon. <code>OCaml</code>'s repl requires two semicolons <code>;;</code>.</p>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p >OCaml REPL</p></th> <th scope="col"><p>Reason REPL</p></th></tr></thead>
  <tr>
    <td>
      <pre>;;</pre>
    </td>
    <td>
      <pre>;</pre>
    </td>
  </tr>
</table>
<h3>Operator Renaming</h3>
<p><code>Reason</code> has all of <code>OCaml</code>'s infix operators, but a couple of operators
are <em>expressed</em> differently.
In <code>Reason</code>, structural equality is written as <code>==</code>, and reference equality
(physical equality)
is written as <code>===</code> (so just remember to add an extra <code>=</code> to what <code>OCaml</code>
requires). In <code>Reason</code>, to achieve the corresponding <em>inequality</em>,
simply swap the first character with a <code>!</code> character. (<code>!=</code> for structural
inequality, and <code>!==</code> for reference inequality). <code>Reason</code>'s
symbol choices are slightly more consistent and follow the ES6 conventions.</p>
<blockquote>
<table>
</blockquote>
  <thead><tr><th scope="col"><p>Equality</p></th> <th scope="col"><p>Expressed in OCaml via</p></th> <th scope="col"><p>Expressed in Reason via</p></th></tr></thead>
  <tr>
    <td>
      <pre>
structural</pre>
    </td>
    <td>
      <pre>
x = y</pre>
    </td>
    <td>
      <pre>
x == y</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>
reference</pre>
    </td>
    <td>
      <pre>
x == y</pre>
    </td>
    <td>
      <pre>
x === y</pre>
    </td>
  </tr>
  <thead><tr><th scope="col"><p>Inequality</p></th> <th scope="col"><p>Expressed in OCaml via</p></th> <th scope="col"><p>Expressed in Reason via</p></th></tr></thead>
  <tr>
    <td>
      <pre>
structural</pre>
    </td>
    <td>
      <pre>
x <> y</pre>
    </td>
    <td>
      <pre>
x != y</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>
reference</pre>
    </td>
    <td>
      <pre>
x != y</pre>
    </td>
    <td>
      <pre>
x !== y</pre>
    </td>
  </tr>
</table>
<h3>Local Scope</h3>
<p><code>Reason</code>'s lexical scoping is exactly the same as <code>OCaml</code>'s, but let bindings
syntactically resemble "block scope" which is more familiar to many
developers. In <code>Reason</code>, they are created with <code>{}</code> braces, which
may contain both <code>let</code> bindings and imperative commands, separated by <code>;</code>.
All blocks <em>evaluate</em> to the last line and the semicolon on the last line is
optional. <code>{}</code> braces are only needed if you have more than one item to chain
together via <code>;</code>.</p>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
let \_ =
  let msg = "Hello" in
  print\_string msg;
  let msg2 = "Goodbye" in
  print\_string msg2</pre>
    </td>
    <td>
      <pre>
{
  let msg = "Hello";
  print\_string msg;
  let msg2 = "Goodbye";
  print\_string msg2
};</pre>
    </td>
  </tr>
</table>
<p><code>Reason</code>'s <code>{}</code> syntax removes many commonly reported pain points in <code>OCaml</code>'s
syntax:</p>
<ul>
<li>Double semicolons are removed entirely.</li>
<li><code>begin</code>/<code>end</code> is removed entirely.</li>
<li>Infamous imperative parsing <a href="https://github.com/ocaml/ocaml/pull/278">issues</a> are gone.</li>
<li>Module bodies and local scope are unified.</li>
</ul>
<h3>Local Scope Vs. Module Bodies</h3>
<p>In <code>Reason</code>, everything that can go between the <code>{}</code> in <a href="#reason-vs-ml-syntax-local-scope">Local
Scopes</a> and in module bodies. You can usually
even cut/paste code between the two contexts. In <code>OCaml</code>, the syntaxes for the two
contexts are very different. (Local scope requires trailing <code>in</code>, but module bodies do
not and some imperative statements must be assigned to <code>_</code> or <code>()</code>, or else use double <code>;;</code>).
<code>Reason</code> greatly simplifies the syntax for new <em>and</em> experienced ML programmers.</p>
<blockquote>
<table>
  <thead><tr> <th scope="col"><p>OCaml Module Body</p></th><th scope="col"><p>Reason Module Body</p></th></tr></thead>
  <tr>
    <td>
      <pre>
let ten = 10
let () = imperativeFunc ten ten
let () = imperativeFunc 0 0</pre>
    </td>
    <td>
      <pre>
let ten = 10;
imperativeFunc ten ten;
imperativeFunc 0 0;</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10;;
imperativeFunc ten ten;;
imperativeFunc 0 0;;</pre>
    </td>
    <td>*Same as above*</td>
  </tr>
  <thead><tr> <th scope="col"><p>OCaml Local Scope</p></th><th scope="col"><p>Reason Local Scope</p></th></tr></thead>
  <tr>
    <td>
      <pre>
let ten = 10 in
let \_ = imperativeFunc ten ten in
imperativeFunc 0 0</pre>
    </td>
    <td>
<div class="gatsby-highlight">
      <pre class="hljs lang-none"><code>   *same <span class="hljs-keyword">as</span> above*

&lt;/td&gt;</code></pre>
      </div>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in begin
  imperativeFunc ten ten;
  imperativeFunc 0 0
end</pre>
    </td>
    <td>
       *same as above*
    </td>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in (
  imperativeFunc ten ten;
  imperativeFunc 0 0
)</pre>
    </td>
    <td>
       *same as above*
    </td>
  </tr>
</table>
</blockquote>
<h3>Tuples and Records</h3>
<p>In <code>Reason</code>, tuples always require parentheses. This requirement makes <code>Reason</code> easier to
read and also removes the need for type annotations inside of tuple members
to be wrapped in <em>additional</em> parentheses.</p>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>let tup = 4, 5</pre>
    </td>
    <td>
      <pre>let tup = (4, 5);</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>let tup = ((1: int), (2:int))</pre>
    </td>
    <td>
      <pre>let tup = (1: int, 2:int);</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>fun ((a:int), (b:int)) -> a </pre>
    </td>
    <td>
      <pre>fun (a:int, b:int) => a</pre>
    </td>
  </tr>
</table>
<p>In <code>Reason</code>, records resemble JavaScript, using <code>:</code> instead of <code>=</code>. Because
<code>Reason</code> tuples always require wrapping parens, records may contain lambdas as values
without needing extra parens.</p>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
let myRec = {x = 0; y = 10}</pre>
    </td>
    <td>
      <pre>
let myRec = {x: 0, y: 10};</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>
let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}</pre>
    </td>
    <td>
      <pre>
let myFuncs = {
  myFun: fun x => x + 1,
  your: fun a b => a + b
};</pre>
    </td>
</table>
<h3>Lists</h3>
<p>Lists in <code>Reason</code> are delimited with commas rather than semi-colons as they are in JavaScript. <code>Reason</code> also uses JavaScript's spread syntax for list concatenation instead of the <code>::</code> operator.</p>
<blockquote>
<table>
<thead><tr> <th scope="col"><p>OCaml Lists</p></th><th scope="col"><p>Reason Lists</p></th></tr></thead>
  <tr>
    <td>
      <pre>let list = [1; 2; 3]</pre>
      <pre>let list = hd :: tl</pre>
    </td>
    <td>
      <pre>let list = [1, 2, 3];</pre>
      <pre>let list = [hd, ...tl];</pre>
    </td>
  </tr>
</table>
</blockquote>
<h3>Type Definitions</h3>
<p>With <code>Reason</code>, types generally look like the values they represent.  There is
only one syntactic pattern to learn for each kind of type. Whereas in <code>OCaml</code>,
there are separate syntaxes for tuple types <code>(x * y)</code> and tuple values
<code>(x, y)</code>).</p>
<blockquote>
<table>
<thead><tr> <th scope="col"><p>OCaml Tuples</p></th><th scope="col"><p>Reason Tuples</p></th></tr></thead>
  <tr>
    <td>
      <pre>
type tuple = int \* int
let tup: tuple = (10, 30)</pre>
<div class="gatsby-highlight">
      <pre class="hljs lang-none"><code>&lt;/td&gt;
&lt;td&gt;
  &lt;pre&gt;</code></pre>
      </div>
<p>type tuple = (int, int);
let tup: tuple = (10, 30);</pre>
</td></p>
  </tr>
<thead><tr> <th scope="col"><p>OCaml Records</p></th><th scope="col"><p>Reason Records</p></th></tr></thead>
  <tr>
    <td>
      <pre>
type r =
  {x: int; y: int};
let myRec: r = {x = 0; y = 10};</pre>
<div class="gatsby-highlight">
      <pre class="hljs lang-none"><code>&lt;/td&gt;
&lt;td&gt;
  &lt;pre&gt;</code></pre>
      </div>
<p>type r =
{x: int, y: int};
let myRec: r = {x: 0, y: 10};</pre>
</td></p>
  </tr>
<thead><tr> <th scope="col"><p>OCaml Functions</p></th><th scope="col"><p>Reason Functions</p></th></tr></thead>
  <tr>
    <td>
      <pre>
type func = int -> int;
let x: func = fun a -> a + 1;</pre>
    </td>
    <td>
      <pre>
type func = int => int;
let x: func = fun a => a + 1;</pre>
    </td>
  </tr>
</table>
</blockquote>
<h3>Functions</h3>
<p><code>OCaml</code> has three ways to define functions:</p>
<ul>
<li>Some <code>OCaml</code> forms use arrows <code>-></code>, some use equals <code>=</code>.</li>
<li>Some <code>OCaml</code> forms use the <code>fun</code> keyword, others use the <code>function</code> keyword.</li>
</ul>
<p><code>Reason</code> also supports the same three ways to define lambdas, but for
consistency:</p>
<ul>
<li>Every <code>Reason</code> form uses an <code>=></code> arrow in one way or another.*</li>
<li><code>Reason</code> uses at most one keyword (<code>fun</code>).</li>
<li>As with all pattern matching, the leading bar <code>|</code> is required in the single
argument pattern match form.</li>
</ul>
<h6>Single argument match functions</h6>
<p><code>OCaml</code> has a function definition (<code>function |</code>) which is considered to be
equivalent of <code>function a -> match a with ...</code>. <code>Reason</code> has the same, but
the syntax makes it clear how it is actually an extension of a single argument
function. The single case match is a natural extension of the simple lambda,
and the multicase lambda is a natural extension of the single case lambda.</p>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p>Form</p></th><th scope="col"><p>Ocaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      lambda
    </td>
    <td>
      <pre>
fun pat -> e</pre>
    </td>
    <td>
      <pre>
fun pat => e</pre>
    </td>
  </tr>
  <tr>
    <td>
      one match case
    </td>
    <td>
      <pre>
function | pat -> e</pre>
    </td>
    <td>
      <pre>
fun | pat => e</pre>
    </td>
  </tr>
  <tr>
    <td>
      many cases
    </td>
    <td>
      <pre>
function | pat -> e
         | pat2 -> e</pre>
    </td>
    <td>
      <pre>
fun | pat => e
    | pat2 => e</pre>
    </td>
  </tr>
</table>
<h6>Let binding for curried functions</h6>
<p>Both <code>OCaml</code> and <code>Reason</code> syntax offer a syntactic sugar for expressing curried
functions. The following table shows three equivalent definitions which are
identical once parsed. As always, all <code>Reason</code> functions include an <code>=></code> arrow.</p>
<blockquote>
<table> <thead><tr><th scope="col"><p>Ocaml</p></th><th
</blockquote>
<div class="gatsby-highlight">
      <pre class="hljs lang-none"><code>    scope=<span class="hljs-string">"col"</span>&gt;&lt;p&gt;Reason&lt;/p&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;</code></pre>
      </div>
  <tr>
    <td>
      <pre>
let x = fun a -> fun b -> e</pre>
    </td>
    <td>
      <pre>
let x = fun a => fun b => e;</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>
let x = fun a b -> e</pre>
    </td>
    <td>
      <pre>
let x = fun a b => e;</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>
let x a b = e</pre>
    </td>
    <td>
      <pre>
let x a b => e;</pre>
    </td>
  </tr>
</table>
<h3>Annotating Function Arguments</h3>
<p>In both <code>Reason</code> and <code>OCaml</code>, arguments are annotated with types by (as with
everything else), wrapping them in parenthesis after appending
<code>:typeAnnotation</code>.</p>
<div class="gatsby-highlight">
      <pre class="hljs lang-reason"><code><span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg<span class="hljs-params"> :<span class="hljs-params"> argType)<span class="hljs-params"> </span></span></span></span></span>=&gt; returnValue;</code></pre>
      </div>
<div class="gatsby-highlight">
      <pre class="hljs lang-reason"><code><span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg<span class="hljs-params"> :<span class="hljs-params"> argType)<span class="hljs-params"> </span></span></span></span></span>=&gt; <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg2<span class="hljs-params"> :<span class="hljs-params"> arg2Type)<span class="hljs-params"> </span></span></span></span></span>=&gt; returnValue;</code></pre>
      </div>
<div class="gatsby-highlight">
      <pre class="hljs lang-reason"><code><span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg<span class="hljs-params"> :<span class="hljs-params"> argType)<span class="hljs-params"> (arg2<span class="hljs-params"> :<span class="hljs-params"> arg2Type)<span class="hljs-params"> </span></span></span></span></span></span></span></span>=&gt; returnValue;</code></pre>
      </div>
<p>Both <code>Reason</code> and <code>OCaml</code> allow annotating the return type, when using the
"super sugared let binding" form.</p>
<div class="gatsby-highlight">
      <pre class="hljs lang-ocaml"><code><span class="hljs-comment">(* OCaml *)</span>
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span> = (a, b)
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>]
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-keyword">fun</span> x -&gt; x + a + b</code></pre>
      </div>
<div class="gatsby-highlight">
      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* Reason */</span>
<span class="hljs-keyword">let</span> myFunc (a:int) (b:int) :(int, int) =&gt; (a, b);
<span class="hljs-keyword">let</span> myFunc (a:int) (b:int) :list int =&gt; [<span class="hljs-number">1</span>];
<span class="hljs-keyword">let</span> myFunc (a:int) (b:int) :(int =&gt; int) =&gt; <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> x<span class="hljs-params"> </span></span></span>=&gt; x + a + b;</code></pre>
      </div>
<blockquote>
<p>Because we're using <code>=></code> for all functions everywhere in <code>Reason</code>, there's
one case where we need to add extra parens around a return type that is
itself a function type.</p>
</blockquote>
<h3>Type Parameters</h3>
<h6>OCaml:</h6>
<p>OCaml's type applications (think "generics"), are applied in reverse order.</p>
<p>With OCaml, there are some unintuitive consequences of this.</p>
<div class="gatsby-highlight">
      <pre class="hljs lang-ocaml"><code>    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">2</span>]

    <span class="hljs-keyword">type</span> listOfListOfInts = <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">list</span>

    <span class="hljs-comment">(* Parsed as: *)</span>
    <span class="hljs-keyword">type</span> listOfListOfInts = (<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span>) <span class="hljs-built_in">list</span></code></pre>
      </div>
<p>Things get even more strange when type constructors accept multiple parameters.
Multiple arguments require parenthesis and commas to separate type parameters,
but those parentheses don't represent tuples. The parentheses/comma form must
also be given when constructing type instances such as <code>(int, string) tuple</code>.</p>
<div class="gatsby-highlight">
      <pre class="hljs lang-ocaml"><code>    <span class="hljs-keyword">type</span> (<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'b</span>) tuple = <span class="hljs-symbol">'a</span> * <span class="hljs-symbol">'b</span>

    <span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = (<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple <span class="hljs-built_in">list</span>

    <span class="hljs-comment">(* Which is parsed as: *)</span>
    <span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = ((<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple) <span class="hljs-built_in">list</span>

    <span class="hljs-comment">(* Which allows a list of (tuples of (string and int)) *)</span>
    <span class="hljs-keyword">let</span> tuples: listOfTuplesOfStringAndInt = [(<span class="hljs-string">"asdf"</span>, <span class="hljs-number">3</span>)]</code></pre>
      </div>
<h6>Reason:</h6>
<p>In summary, Reason unifies almost all of the syntax into simple "function
application" style meaning that type parameters follow the same space-separated
list pattern seen everywhere else in the syntax. As with everything else,
parentheses may be used to enforce precedence. This results in fewer syntactic
patterns to learn.</p>
<p>For example, you can imagine <code>list</code> being a "function" for types that accepts a
type and returns a new type.</p>
<table>
  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
let x: int list = [2]
type listOfListOfInts =
  int list list
type ('a, 'b) tup = ('a \* 'b)
type pairs = (int, int) tup list
let tuples: pairs = [(2, 3)]</pre>
    </td>
    <td>
      <pre>
let x: list int = [2];
type listOfListOfInts =
  list (list int);
type tup 'a 'b = ('a, 'b);
type pairs = list (tup int int)
let tuples: pairs = [(2, 3)]</pre>
    </td>
  </tr>
</table>
<h3>Tuples as Type Parameters</h3>
<p>Because <code>OCaml</code> uses parens and commas to represent multiple arguments to type
constructors, it's confusing when one of the arguments to a type constructor is
itself a tuple. In <code>OCaml</code>, it's difficult to remember the difference between a
type constructor accepting multiple arguments and a type constructor accepting
a single argument which happens to be a tuple.</p>
<p>The following examples shows the difference between passing <em>two</em> type
parameters to <code>pair</code>, and a <em>single</em> type parameter that happens to be a tuple.</p>
<table>
  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
type intPair = (int, int) pair
type pairList = (int \* int) list</pre>
    </td>
    <td>
      <pre>
type intPair = pair int int;
type pairList = list (int, int);</pre>
    </td>
  </tr>
</table>
<ul>
<li>In <code>Reason</code>, syntax that represent tuple or tuple types, always looks like
tuples.</li>
<li>In <code>Reason</code>, syntax that represent records or record types, always look like
records.</li>
<li>Just about everything else uses the syntactic pattern of function application
(space separated arguments).</li>
</ul>
<h3>Variants</h3>
<h6>OCaml</h6>
<ul>
<li><code>OCaml</code> already expects constructor argument types to be specified in tuple
form, so it's confusing when a single constructor expects a single argument
that <em>happens</em> to be a tuple type.</li>
<li>What's even more confusing is that the constructors don't <em>actually</em> accept
tuples, yet the syntax appear to resemble tuples.</li>
<li>Sometimes the syntax for instantiating a constructor with multiple arguments
overlaps the syntax for constructing a variant with a single argument that
happens to be a tuple - so it looks <em>exactly</em> like you <em>are</em> supplying a
tuple when you are not actually supplying a tuple.</li>
</ul>
<h6>Reason</h6>
<ul>
<li>Variant constructor types are expected to be listed as space separated lists,
using parenthesis to group precedence (as with <strong>everything</strong> else).</li>
<li>Constructing instances of the variant (as you would have guessed) follows
function application style (space separated lists).</li>
<li>Tuples <strong>always</strong> <em>look</em> like tuples, and anything that looks like a tuple
<em>is</em> a tuple.</li>
</ul>
<table>
  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
type myVariant =
   | HasNothing
   | HasSingleInt of int
   | HasSingleTuple of (int \* int)
   | HasMultipleInts of int \* int
   | HasMultipleTuples
      of (int \* int) \* (int\* int)
<p>let a = HasSingleInt 10
let a = HasSingleTuple (10, 10)
let a = HasMultipleInts (10, 10)
let a =
HasMultipleTuples (
(10, 10),
(10, 10)
)</p>
<p>let res = match x with
| HasNothing -> 0
| HasSingleInt x -> 0
| HasSingleTuple (x, y) -> 0
| HasMultipleInts (x, y) -> 0
| HasMultipleTuples
((x, y),
(q, r)) -> 0</pre>
</td>
<td>
<pre>
type myVariant =
| HasNothing
| HasSingleInt int
| HasSingleTuple (int, int)
| HasMultipleInts int int
| HasMultipleTuples
(int, int) (int, int);</p>
<p>let a = HasSingleInt 10;
let a = HasSingleTuple (10, 10);
let a = HasMultipleInts 10 10;
let a =
HasMultipleTuples
(10, 10)
(10, 10);</p>
<p>let res = switch x {
| HasNothing => 0
| HasSingleInt x => 0
| HasSingleTuple (x, y) => 0
| HasMultipleInts x y => 0
| HasMultipleTuples
(x, y)
(q, r) => 0
};</pre>
</td></p>
  </tr>
</table>
<h3>Pattern Matching</h3>
<h6>OCaml</h6>
<h6>Reason</h6>
<ul>
<li>Uses the <code>switch</code> keyword, and doesn't require <code>with</code>.</li>
<li><em>Requires</em> wrapping <code>switch</code> cases in <code>{}</code> to avoid confusing and error
prone mis-parsing when pattern matching is embedded in other pattern
matching.</li>
<li>Uses the <code>=></code>.</li>
<li>Requires the leading bar. This is a good idea because it frees up other
possibilities in the grammar without conflicts.</li>
</ul>
<p>Can you spot the error in the <code>OCaml</code> example? This is one of the most common
mistakes among <code>OCaml</code> programmers. The second <code>match</code> <em>must</em> be wrapped in
parentheses, otherwise the <code>Some</code> case is parsed as belonging to the outer
<code>match</code>. <code>Reason</code>'s required <code>{}</code> blocks around match cases prevent this
issue.</p>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p>OCaml (BROKEN)</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
let res = match x with
  | A (x, y) -> match y with
    | None -> 0
    | Some i -> 10
  | B (x, y) -> 0</pre>
    </td>
    <td>
      <pre>
let res = switch x {
  | A (x, y) => switch y {
    | None => 0
    | Some i => 10
  }
  | B x y => 0
};</pre>
    </td>
  </tr>
</table>
<h3>Modules and Signatures</h3>
<h6>Defining Modules/Signatures</h6>
<table>
  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
module type MySig = sig
  type t = int
  val x: int
end
module MyModule: MySig = struct
  type t = int
  let x = 10
end
module MyModule = struct
  module NestedModule = struct
     let msg = "hello";
  end
end
      </pre>
    </td>
    <td>
      <pre>
module type MySig = {
  type t = int;
  let x: int;
};
module MyModule: MySig = {
  type t = int;
  let x = 10;
};
module MyModule = {
  module NestedModule = {
     let msg = "hello";
  };
};
      </pre>
    </td>
  </tr>
</table>
<h5>Functors Types</h5>
<p>In the same way that type parameters (think generics) were made consistent with
function application syntax, <code>Reason</code> also unifies the syntax for Functors.</p>
<p>In <code>Reason</code>, functor parsing rules are almost identical to the function
parsing rules, using <code>=></code> to represent curried application.</p>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
module type FType =
    functor (A: ASig) ->
    functor (B:BSig) -> Result
      </pre>
    </td>
    <td>
      <pre>
module type FType =
    (A: ASig) =>
    (B:BSig) => Result;
      </pre>
    </td>
  </tr>
</table>
<h3>Functors</h3>
<p>In <code>Reason</code>, the syntax for creating and applying functors is nearly identical
to the syntax for creating/applying functions. Also, functor <em>application</em> is
consistent with function application (again, space separated lists).</p>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
module F =
  functor (A:ASig) ->
  functor (B:BSig) ->
    struct end</pre>
    </td>
    <td>
      <pre>
module F =
  fun (A:ASig) =>
  fun (B:BSig) =>
    {};</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>
module F =
  functor
    (A:ASig)
    (B:BSig) -> struct end</pre>
    </td>
    <td>
      <pre>
module F =
  fun (A:ASig)
      (B:BSig) => {};</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>
module F
       (A:ASig)
       (B:BSig) =
         struct end</pre>
    </td>
    <td>
      <pre>
module F
           (A:ASig)
           (B:BSig) =>
             {};</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>
module Res = F(A)(B)</pre>
    </td>
    <td>
      <pre>
module Res = F A B;</pre>
    </td>
  </tr>
</table>
<blockquote>
<p>* <em>Note: There is currently a known inconsistency where functors do not
conform to function application syntax when in type annotation position - see
<code>formatTest/modules.re</code>.</em></p>
</blockquote>
<h3>Various Improvements</h3>
<p>OCaml doesn't require parens around sequences <code>(a;b;c;d)</code> or tuples <code>(x,y)</code>, so
that ends up ruling out a bunch of other very convenient syntax rules.  Since
Reason always uses <code>{}</code> to enclose sequences or let bindings, and <code>Reason</code>
always requires <code>()</code> around tuples, many other syntax constructs are expressed
more intuitively, without requiring extra wrapping in parenthesis.</p>
<h6>Lambdas as record fields no longer need extra parens</h6>
<p>This is a welcomed improvement because the <code>OCaml</code> type errors the user would
see were very confusing when it would believe the function's return value
was a tuple with infix <code>,</code> comma.</p>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}</pre>
    </td>
    <td>
      <pre>
let myFuncs = {
  myFun: fun x => x + 1,
  your: fun a b => a + b
}</pre>
    </td>
  </tr>
</table>
<h6>Lambdas as match results no longer need extra parens</h6>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
let x = match prnt with
  | None -> fun a -> blah
  (\* Extra () required ! \*)
  | Some "\_" -> (fun a -> ())
  | Some "ml" -> blah
      </pre>
    </td>
    <td>
      <pre>
let x = switch prnt {
| None => fun a => blah
| Some "_" => fun a => ()
| Some "ml" => blah
};</pre>
    </td>
  </tr>
</table>
<h6>Lambdas and type annotations in tuples no longer require extra parens</h6>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
let tuple =
  ((fun x -> x), 20)
let tuple =
  (("hi": string), (20: int))
      </pre>
    </td>
    <td>
      <pre>
let tuple =
  (fun x => x, 20);
let tuple =
  ("hi": string, 20: int);
      </pre>
    </td>
  </tr>
</table>
<h3>Various Differences</h3>
<h5><code>as</code> precedence</h5>
<p>With <code>Reason</code>, <code>as</code> has a higher precedence than <code>|</code> bar. This allows creating <code>as</code> aliases
for entire rows in pattern matching.</p>
<table>
  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
let ppp = match MyThing 20 with
  | (MyThing x as ppp)
  | (YourThing x as ppp) -> ppp;
      </pre>
    </td>
    <td>
      <pre>
let ppp = switch (MyThing 20) {
| MyThing x as ppp
| YourThing x as ppp => ppp;
};
      </pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>
let | (MyThing \_ as ppp)
    | (YourThing \_ as ppp) = ppp;</pre>
    </td>
    <td>
      <pre>
let | MyThing \_ as ppp
    | YourThing \_ as ppp = ppp;</pre>
    </td>
  </tr>
</table>
<h3>Mutable Record Field Updates</h3>
<p>Because equalities and their negations have been made more consistent in <code>Reason</code>,
the <code>=</code> operator is available for mutable field update.</p>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p >OCaml</p></th> <th scope="col"><p>Reason</p></th></tr></thead>
  <tr>
    <td>
      <pre>
myRec.field <- "next"</pre>
    </td>
    <td>
      <pre>
myRec.field = "next"</pre>
    </td>
  </tr>
</table>
<h5>Prefix operators</h5>
<p>In Reason, <code>!</code> and other prefix operators have lower precedence than dot <code>.</code> or send <code>#</code>.
This is more consistent with what other languages do, and is more practical
when (or if) the <code>!</code> symbol is used to represent boolean <code>not</code>.</p>
<blockquote>
<table>
<thead>
<tr>
<th>Ocaml</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td><pre>
   let x = !(foo.bar);    
</pre></td>
<td><pre>
    let x = !foo.bar;        
</pre></td>
</tr>
<tr>
<td><pre>
   let x = !(foo#bar);    
</pre></td>
<td><pre>
    let x = !foo#bar;        
</pre></td>
</tr>
<tr>
<td><pre>
   let x = !(!foo.bar);   
</pre></td>
<td><pre>
    let x = !(!foo).bar;     
</pre></td>
</tr>
<tr>
<td><pre>
   let x = !(!foo#bar);   
</pre></td>
<td><pre>
    let x = !(!foo)#bar;     
</pre></td>
</tr>
<tr>
<td><pre>
   let x = !(!(foo.bar)); 
</pre></td>
<td><pre>
    let x = !(!foo.bar);     
</pre></td>
</tr>
<tr>
<td><pre>
   let x = !(!(foo#bar)); 
</pre></td>
<td><pre>
    let x = !(!foo#bar);     
</pre></td>
</tr>
<tr>
<td><pre>
   let x = !!(foo.bar);   
</pre></td>
<td><pre>
    let x = !!foo.bar;       
</pre></td>
</tr>
<tr>
<td><pre>
   let x = !!(foo#bar);   
</pre></td>
<td><pre>
    let x = !!foo#bar;       
</pre></td>
</tr>
<tr>
<td><pre>
   let x = !~(foo.bar);   
</pre></td>
<td><pre>
    let x = !~foo.bar;       
</pre></td>
</tr>
<tr>
<td><pre>
   let x = !~(foo#bar);   
</pre></td>
<td><pre>
    let x = !~foo#bar;       
</pre></td>
</tr>
</tbody>
</table>
</blockquote>
<h6>Comment Escaping</h6>
<p>Because Reason uses C-style comments, some obscure custom prefix/infix
operators must be written differently.  The rules for prefix/infix operators
are the same as in OCaml syntax, but with the following exceptions:</p>
<p>Specifically, if any character except the first in an prefix/infix operator is
a star or forward slash, that must be first escaped with a backslash. These will
be parsed <em>without</em> the backslash when added to the AST. When reprinted, the
escape backslashes are added back in automatically.</p>
<blockquote>
<table>
<thead>
<tr>
<th>OCaml</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>
let (/*) a b => a + b;       
</code></td>
<td><code>
     let (/
\
*
) a b => a + b;         
</code></td>
</tr>
<tr>
<td><code>
let x = 12 /-
*
 23 /-
*
 12;  
</code></td>
<td><code>
     let x = 12 /-
\
*
 23 /-
\
*
 12; 
</code></td>
</tr>
<tr>
<td><code>
let y = (/*) a b;            
</code></td>
<td><code>
     let y = (/
\
*
) a b;            
</code></td>
</tr>
<tr>
<td><code>
let (!=*) q r => q + r;      
</code></td>
<td><code>
     let (!=
\
*
) q r => q + r;      
</code></td>
</tr>
<tr>
<td><code>
let res = q (!=*) r;         
</code></td>
<td><code>
     let res = q (!=
\
*
) r;         
</code></td>
</tr>
<tr>
<td><code>
let (!=/*) q r => q + r;     
</code></td>
<td><code>
     let (!=
/
\
*
) q r => q + r;    
</code></td>
</tr>
<tr>
<td><code>
let res = q (!=/*) r;        
</code></td>
<td><code>
     let res = q (!=
/
\
*
) r;       
</code></td>
</tr>
</tbody>
</table>
</blockquote>
<h6>Operator Renaming</h6>
<p>If <code>Reason</code> uses <code>==</code> to represent <code>OCaml</code>'s <code>=</code>, and
uses <code>===</code> to represent <code>OCaml</code>'s <code>==</code>, then how would <code>Reason</code> represent <code>OCaml</code>'s
<code>===</code> symbol (if it were defined)? <code>Reason</code> provides a way! "Escape" the triple
equals symbol!</p>
<blockquote>
<table>
</blockquote>
  <thead><tr> <th scope="col"><p>Identifier</p></th><th scope="col"><p>Meaning</p></th> <th scope="col"><p>Expressed in OCaml via</p></th> <th scope="col"><p>Expressed in Reason via</p></th></tr></thead>
  <tr>
  <tr>
    <td>
      <pre>
"==="</pre>
    </td>
    <td>
      <pre>
Custom value</pre>
    </td>
    <td>
      <pre>
x === y</pre>
    </td>
    <td>
      <pre>
x \=== y</pre>
    </td>
  </tr>
</table></div></div></div></div></div></div></body></html>